//  ==================================================
//  ===  как фукнкции обращаются к переменным пример 1
//  ==================================================
let a = 10;

function f1() {
   console.log('a(global) = ' + a);
}

// f1();  // a - global 10

//  ==================================================
//  ===  как фукнкции обращаются к переменным пример 2
//  ==================================================

function f2() {
   let a = 9; // обращаться к данной переменной можно только внутри функции
   console.log('a(local)= ' + a);
}

// f2();  // a(local)= 9
// console.log(a);

//  ==================================================
//  ===  иногда значения нельзя разместить только внутри
//  ==================================================

let count = 0;
function step() {
   count++;
   console.log(count);
}
// step();
// step();
// step();

const constStep = function step() {
   count++;
   console.log('constStep', count);
}
// constStep();
// constStep();

//  ==================================================
//  ===  а давайте ка обернем это все функцией (замыкания)
//  === closure
//  ==================================================
// (
//    function constStep22() {
//       let count = 0;
//       function step() {
//          count++;
//          console.log(count);
//       }
//    }
// )(); // выдаст ошибку

// Шаг 1
// Берём функцию выше и...

// let count = 0;
// function step0() { // изменим имя функции
//    count++;
//    console.log(count);
// }


// Шаг 2
// оборачиваем её в другую функцию. Нужно дать имя новой функции.
function ttt11() {
   let count = 0;
   // step0();
   function step0() {
      count++;
      console.log('count ttt11', count);
   }
}

// выполним эту функцию
// let z21 = ttt(); // посчитает один каунт 1
let z21 = ttt11()
z21;
// z();// попытаемся выполнить - получим ошибку, т.к. z - не фун-ия

// console.log(z21);// undefined т.к. ф. ttt11() ничего не возвращает


// но сейчас, мы не можем выполнить функцию step0, кото-ая внутри функции ttt11
// step0(); // ошибка
ttt11(); // сработает

// Шаг 3.
// напишем запуск фу-ии step1 внутри ttt
function ttt() {
   let count = 0;
   step0();
   function step0() {
      count++;
      console.log('ttt', count);
   }
}

// теперь эта функция запуститься из строки let z = ttt();,
let z22 = ttt(); // запуститься
// z22; // не сработает
// console.log(z22); // undefined
// ttt(); // запуститься один раз счётчик и выведет 1

// Шаг 4.
// Дадим новое имя ф. 
// перед ф. step0 - напишем return
// удалим вызов функции step0
function createStep() {
   let count = 0;
   return function step0() {
      count++;
      console.log(count);
   }
}
// Ф. createStep - создаёт область видимости для всех событий и переменных, только внутри себя.
// в том числе и для вложенных в неё функций
let newStep1 = createStep(); // создаём переменную со своей УНИКАЛЬНОЙ (изолированной) областью видимости
// console.log(createStep); // выдаст код функции createStep
// console.log(newStep1); // выдаст выполнение функции createStep - будет код функции step0. Значит её можно выполнять, добавив скобки.
// newStep1(); // 1
// newStep1(); // 2
// newStep1(); // 3
// newStep1(); // 4

// Шаг 5.
// можно удалить имя функции step0 - т.к. её напрямую нам вызывать нет смысла
function createStep() {
   let count = 0;
   return function () {
      count++;
      console.log(count);
   }
}
// создаём newStep2 у которой будет своя УНИКАЛЬНАЯ (изолированная) область видимости
//отличной от newStep1
let newStep2 = createStep();

// у каждой переменной ф. будет своя уникальная (изолированная) область видимости и свои переменные
// это называется замыкания.
// newStep1(); // 1
// newStep1(); // 2
// newStep2(); // 1
// newStep1(); // 3
// newStep2(); // 2
// newStep1(); // 4
// newStep2(); // 3
// newStep2(); // 4

// замыкание - это создание ф. в которую помещаются нужные данные и способы манипулирования ими - функция
// из-за того что всё это помещено в ф-ию, то функция будет выполнена и создастся изолированная область
// где данные переменные будут находится и функции прописанные внутри этой замфкания (нашей функции) получают к ним доступ
// Таким образом создаются изолированные области для каждой переменной которой присвоена эта функция замыкания


//  ==================================================
//  === сделаем еще более удобным (замыкания)
//  ==================================================
// добавим агргументы в функцию
function createStep2(n = 0) {
   let count = n;
   return function () {
      count++;
      console.log(count);
      return count; // можно возвратить count, это будет тоже самое что и возвращает функция 
   }
}
// в одну переменнную передадим агрумент в другую - нет. Результаты будут разные этих переменных.
// но мы не можем передавать аргументы в ф.  newStep3. Что бы передавать агрументы, добавим аргумент в возвращаемую функцию
let newStep3 = createStep2();
let newStep4 = createStep2(200);
newStep3(100); // 1
newStep4(); // 201
console.log('newStep3()', newStep3());
console.log('newStep4()', newStep4());
// newStep3(); // 2
// newStep4(); // 202
// let step3 = createStep2(10);
// step3();

// добавим агргументы в возвращаемую функцию
function createStep3(a = 0) {

   return function (b = 0) {
      console.log('a + b = ', a + b);
      return a + b;
   }
}

// теперь можно передавать два аргумента. Один в основную функцию, второй в возвращаемую ф.
let newStep5 = createStep3(1);
let newStep6 = createStep3(200);
let newStep7 = createStep3();
console.log('newStep5', newStep5(500)); // 500 + 1
console.log('newStep6', newStep6(100)); // 100 + 200
console.log('newStep7', newStep7()); // 0


//  ==================================================
//  === Замыкание ( закрытие, сокрытие, скрытие )
//  === возможность закрыть и использовать переменные в каком-то блоке видимости
//  === защищать данные
//  === не гадить в коде
//  ==================================================


//  ==================================================
//  === Задача на попрошайку, с рекурсией
//  ==================================================

function randomInteger(min, max) {
   // получить случайное число от (min-0.5) до (max+0.5)
   let rand = min - 0.5 + Math.random() * (max - min + 1);
   return Math.round(rand);
}

// Шаг 1. Обычная рекурсия.
// минусы - это внешняя переменная.
let s = 0;
function beggar() {
   s += randomInteger(0, 100);
   console.log(s);
   if (s >= 250) return;
   beggar();
}
// beggar();

// Шаг 2.
// оборачиваем предыдущую ф. в другую ф.
// ставим return для ф. beggar. Нельзя убрать имя этой ф., т.к. она вызывает сама себя по имени
function createBeggar() {
   let s = 0;
   return function beggar() {
      s += randomInteger(0, 100);
      console.log(s);
      if (s >= 250) return;
      beggar();
   }
}

// создадим две переменные
let begg1 = createBeggar();
// begg1();
console.log('======================');
let begg2 = createBeggar();
// begg2();



//  ==================================================
//  === Задача создания валидаторов 
//  ==================================================

let p;

function btn(x, n) {
   return function pow() {
      if (n == 1) {
         return x;
      } else {
         return pow(x, n - 1);
      }
   }
}

document.querySelector('.b-3').addEventListener('click', () => {
   document.querySelector('.out-1').textContent = btn(2, 1);
})

// function () {
//    let p = 10;
//    let q = document.querySelector('.b-1');
//    q.onclick = () => {
//       console.log('work q 1');
//       p = p + 1;
//       console.log(p);
//    }
// }